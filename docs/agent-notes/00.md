# Step 00 — Project Scaffold

## 1) Summary

This step bootstraps a new Vue 3 single-page application using Vite. The app is a small social-style demo containing a single post, several users, and several comments. All data is seeded from a static JSON file and managed through an in-memory abstraction layer. The app includes two routed views (post detail and user list), both of which support creating new records that are reflected immediately in the UI. A page refresh resets all state back to the seed data.

## 2) Decisions & Rationale

### Vite as build tool
Vite is the de-facto standard for new Vue 3 projects. It provides instant HMR in development and an optimized Rollup-based production build. There was no reason to consider alternatives (Webpack, Parcel, etc.) given the prompt's explicit requirement.

### Vanilla JavaScript (no TypeScript)
The prompt explicitly asked for vanilla JS. This keeps the scaffold simple and avoids any compile-time type-checking overhead. It also means we rely on Vue's runtime prop validation and good naming conventions for correctness.

### Composition API with `<script setup>`
`<script setup>` is the recommended Composition API sugar in Vue 3. It reduces boilerplate (no explicit `export default`, no `setup()` return) and makes components concise. Every component in this scaffold uses it.

### Hash-based routing (`createWebHashHistory`)
The requirement specified that routing must work in a static hosting environment. Hash-mode routing (`/#/path`) avoids the need for server-side URL rewriting. HTML5 history mode (`createWebHistory`) would require a fallback rule on the server (e.g., redirect all 404s to `index.html`), which static hosts do not universally support out of the box. Hash mode trades a slightly less clean URL for universal portability.

### Reactive in-memory store with `reactive()`
Vue's `reactive()` wraps the seed data in a deep reactive proxy. This means any component that reads from the store (users, comments, etc.) will automatically re-render when mutations occur. There is no need for a state management library (Pinia, Vuex) at this scale. The store module exports plain functions — not a class, not a Pinia store — keeping the abstraction minimal and easy to swap later.

### Deep-clone seed data at initialization
`freshState()` uses `JSON.parse(JSON.stringify(seedData))` to create a detached copy of the imported JSON module. This ensures that the original import (`seedData`) is never mutated, so a page refresh genuinely resets state (the module is re-evaluated and `freshState()` is called again).

### DiceBear avatars
Seed users reference DiceBear SVG avatar URLs parameterized by username. This gives the UI visual personality with zero local asset overhead. The `thumbs` style was chosen arbitrarily; any DiceBear style works.

### Monotonic ID generator
`createUser` and `createComment` generate IDs with a simple incrementing counter (`uid()`). This is adequate for an ephemeral in-memory store. UUIDs would be overkill and harder to read during debugging.

### Component decomposition
The UI is split into six components across two directories:

- **views/** — route-level components (`PostView`, `UsersView`).
- **components/** — reusable pieces (`CommentList`, `CommentForm`, `UserCard`, `CreateUserForm`).

This separation follows Vue community convention: views own the page layout and data orchestration; components are presentation-focused and receive data via props.

### Minimal global styles
Global CSS resets and layout styles live in `App.vue`'s unscoped `<style>` block. Component-specific styles use `<style scoped>`. No CSS framework is introduced — the goal is a clean, readable scaffold, not a production design system.

## 3) Ambiguities Encountered

### "Seed the app with JSON data" — file or inline?
**Options considered:**
1. A separate `.json` file imported at build time.
2. Inline JavaScript objects in the store module.

**Resolution:** Separate `seed.json` file. It makes the seed data inspectable and editable without touching any logic. It also clearly separates data from behavior, which will be useful if future steps want to swap the data source.

### Data layer API surface — return copies or live references?
**Options considered:**
1. Return deep copies from every getter (immutable reads).
2. Return the reactive objects directly (live references).

**Resolution:** Return live reactive references. This is idiomatic Vue — components bind directly to reactive data and the UI updates automatically. Returning copies would require manual refresh logic or a pub/sub layer, adding complexity for no benefit at this stage. If immutability becomes important later, this can be revisited.

### "Several users / comments" — how many?
**Options considered:** 2, 3, 4, 5+.

**Resolution:** 4 users, 3 comments. Enough to look populated without being noisy. The post author (Alice) does not have a comment, leaving room for the user to test adding one.

### Comment form — how to pick an author?
Without authentication, the user must manually select who is commenting. A dropdown of existing users was chosen because it is the simplest UX that satisfies `createComment()` needing an `authorId`. A text input would not tie back to the user data model.

### Route for "Post view" — single post or list?
The prompt says "a single post" and routes to "Post view". Since there is only one post, the route is `/post/:id` with the home page redirecting to `/post/post-1`. This keeps the router generic enough to support multiple posts later, while defaulting to the only existing one.

## 4) Tradeoffs

| Decision | Upside | Downside |
|---|---|---|
| Hash-based routing | Works on any static host with zero config | URLs contain `#` which is less clean |
| `reactive()` store (no Pinia) | Zero extra dependencies, minimal boilerplate | No devtools time-travel, no formal actions/getters separation |
| No TypeScript | Lower barrier, faster scaffold | No compile-time type safety; refactoring relies on conventions |
| No CSS framework | No dependency bloat, full control | UI is plain; future steps may need to introduce one |
| DiceBear external avatars | No local assets to manage | Requires internet access to render avatars |
| Monotonic counter IDs | Simple and readable | Not suitable for distributed or persistent systems |

## 5) Non-Goals

- **Persistent storage.** Data lives only in memory. There is no localStorage, IndexedDB, or backend.
- **Authentication / authorization.** Anyone can post as any user.
- **Production-grade UI/UX.** Styling is intentionally minimal.
- **Testing.** No unit or e2e tests are included in this step.
- **Linting / formatting config.** No ESLint or Prettier configuration is set up yet.
- **CI/CD.** No GitHub Actions or deployment pipeline.
- **TypeScript.** Explicitly excluded by the prompt.

## 6) Files Changed

All files are new (green-field scaffold).

| File | Purpose |
|---|---|
| `package.json` | Project metadata, scripts, dependencies (vue, vue-router, vite, @vitejs/plugin-vue) |
| `vite.config.js` | Vite configuration with the Vue plugin |
| `index.html` | HTML entry point mounting `#app` |
| `src/main.js` | Creates the Vue app, installs the router, mounts |
| `src/App.vue` | Root component: nav bar + `<RouterView>` + global styles |
| `src/router/index.js` | Route definitions using hash-based history |
| `src/data/seed.json` | Seed data: 4 users, 1 post, 3 comments |
| `src/data/store.js` | In-memory reactive data layer (getUsers, getUser, getPost, getComments, createUser, createComment) |
| `src/views/PostView.vue` | Post detail view with comments and comment form |
| `src/views/UsersView.vue` | User list view with user creation form |
| `src/components/CommentList.vue` | Renders a list of comments with author info |
| `src/components/CommentForm.vue` | Form to add a comment to a post |
| `src/components/UserCard.vue` | Displays a single user's avatar, name, and username |
| `src/components/CreateUserForm.vue` | Form to create a new user |
| `README.md` | Project overview, install/run instructions, stage tagging convention |
| `docs/agent-notes/00.md` | This file |

## 7) Manual Verification Checklist

- [ ] `npm install` completes without errors.
- [ ] `npm run dev` starts the dev server.
- [ ] Navigating to the root URL redirects to `/#/post/post-1`.
- [ ] The post view shows the title, author avatar/name, body text, and 3 comments.
- [ ] The "Users" link navigates to `/#/users` and shows 4 user cards.
- [ ] Creating a new user via the form adds a card to the grid immediately.
- [ ] The new user appears in the comment form's author dropdown.
- [ ] Posting a comment adds it to the list and increments the count.
- [ ] Refreshing the page resets all state to the original seed data.
- [ ] `npm run build` produces a `dist/` folder with static assets.
- [ ] Serving `dist/` with a static file server (e.g., `npx serve dist`) works correctly, including route navigation.

## 8) Known Issues / Follow-ups

- **No input validation beyond empty-string checks.** Duplicate usernames are allowed; empty-looking whitespace-only input is trimmed but there are no length limits or character restrictions.
- **No loading or error states.** The data layer is synchronous, so there is nothing to handle currently — but introducing an async data source later will require these.
- **Comment form does not scroll into view after adding a comment.** For long comment lists, the new entry may appear below the fold.
- **No 404 handling.** Navigating to a non-existent post ID shows "Post not found." but there is no dedicated 404 page or redirect.
- **Avatars depend on an external service (DiceBear).** If the service is down or the user is offline, avatars will not render. A local fallback could be added.
- **No accessibility audit has been performed.** Semantic HTML is used (nav, article, headings, labels) but ARIA attributes and keyboard navigation have not been explicitly tested.
- **The `freshState()` deep-clone technique (`JSON.parse(JSON.stringify(...))`) does not preserve `Date` objects.** Dates are stored as ISO strings, so this is not a problem currently, but it would be if the schema evolved to include non-JSON-serializable types.
