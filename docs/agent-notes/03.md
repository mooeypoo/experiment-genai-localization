# Step 03 — Viewing-As Selector & Comment Validation

## 1) Summary

This step introduces the concept of a "current user" — the person the app is being viewed as. A dropdown in the header lets the user switch identity. The comment form no longer has its own author selector; instead it implicitly uses the viewing user. Comment creation now validates input in the data abstraction layer, returning structured errors that the form displays. The `createComment` API signature changed to remove `authorId` (derived from state) and return a `{ comment, errors }` result object.

## 2) Decisions & Rationale

### Current user as shared reactive state in the store
The "viewing as" concept is fundamentally application state — multiple components need to read it (the header dropdown, the comment form's "Posting as" label, and potentially future features). Storing it as a `ref` inside `store.js` and exposing it as a `computed` (`currentUser`) keeps it in the same data layer the prompt asks us to use. Components import it directly; no prop-drilling or provide/inject needed at this scale.

### `currentUser` as a computed export (not a function)
Exporting a `computed` ref rather than a `getCurrentUser()` function means components can use it directly in templates with automatic reactivity. A getter function would also work (since it reads reactive state), but the computed makes the intent clearer — it's a derived value, not an action — and gives Vue's dependency tracking a single cached reference to work with.

### `setCurrentUser(id)` validates before setting
The setter silently ignores invalid IDs rather than throwing. In a small demo app, the only caller is a `<select>` whose options are the users array, so an invalid ID would indicate a bug. A silent no-op is safer than an unhandled exception for this context.

### `createComment` no longer accepts `authorId`
Since the current user is now tracked in the store, having the caller pass `authorId` creates a risk of inconsistency (the form could pass a different user than the one selected in the header). By deriving the author from `currentUserId` inside `createComment`, the store is the single source of truth. This also simplifies the caller — the form only provides `postId` and `body`.

### Validation returns `{ comment, errors }` instead of throwing
Returning a result object is more ergonomic for form UX than try/catch. The component can inspect `errors` to display messages and check `comment` to know if the mutation succeeded. Throwing would work but forces the caller into exception-handling patterns for what is normal user input, not an exceptional circumstance.

### Errors as an array of strings
A simple string array is the lightest validation result format that supports multiple simultaneous errors. An object-keyed-by-field approach (e.g., `{ body: 'required' }`) would help if the form needed per-field inline errors, but the current form is small enough that a single error list is sufficient and easier to render.

### "Posting as" label in the comment form
The form shows "Posting as **Name**" so the user has immediate confirmation of which identity will be attributed to the comment, without having to glance at the header. This is a small UX detail that prevents confusion when the dropdown is off-screen.

### Errors clear on successful submit
When `createComment` returns no errors, the form resets both the textarea and the error list. Previous errors disappear once a valid submission succeeds, avoiding stale feedback.

## 3) Ambiguities Encountered

### Where should the "Viewing as" selector live — header or sidebar?
**Options considered:**
1. In the `AppHeader`, next to the nav links.
2. In a new sidebar or drawer component.
3. As a floating element / FAB.

**Resolution:** Option 1. The prompt says "in the header." A sidebar would be overkill and the app has no sidebar structure. The selector is pushed to the right with `margin-left: auto` so it sits opposite the brand/nav cluster.

### Should the comment form keep its own author dropdown as a fallback?
**Options considered:**
1. Remove the author dropdown entirely; always use the header's current user.
2. Keep both — the form dropdown defaults to the header's current user but can be overridden.

**Resolution:** Option 1. Having two independent author selectors (header and form) would be confusing and contradictory. The prompt says "creating a comment should use the selected viewing user," implying the header selector is authoritative.

### What constitutes valid comment input?
**Options considered:**
1. Only check that `body` is non-empty (after trimming).
2. Check body, check that the post exists, check that a user is selected.
3. Additionally enforce a minimum/maximum length.

**Resolution:** Option 2 — validate body non-emptiness, post existence, and current user selection. These are the three things that could realistically be wrong. Length constraints were not requested and would be arbitrary without UX guidance.

### Should validation live in the store or in the component?
**Options considered:**
1. Validate in the component before calling `createComment`.
2. Validate inside `createComment` in the store (data layer).
3. Both — component does quick checks, store does authoritative validation.

**Resolution:** Option 2, per the prompt's instruction to "keep logic in the data abstraction layer." The component is a thin caller that passes input and displays whatever the store returns. This also means any future caller of `createComment` (e.g., a different UI, a test) gets the same validation for free.

## 4) Tradeoffs

| Decision | Upside | Downside |
|---|---|---|
| `currentUser` as store-level state | Single source of truth; any component can read it | Adds global mutable state; harder to test in isolation |
| `authorId` removed from `createComment` params | Eliminates caller/store identity mismatch | Tightly couples `createComment` to `currentUserId`; can't create a comment "on behalf of" another user |
| Validation in the store, not the component | Centralized; all callers get validation | Component can't short-circuit before calling the store (minor perf, irrelevant at this scale) |
| Error array (not per-field object) | Simple to render; works for small forms | Doesn't support inline per-field error placement |
| Removed form-level author dropdown | Cleaner UX; single selector in the header | If the header is ever removed, there's no way to pick an author |

## 5) Non-Goals

- **Authentication.** The "viewing as" selector is a development convenience, not a security mechanism.
- **Persistent user selection.** Refreshing the page resets the current user to the first seeded user (Alice). localStorage persistence was not requested.
- **Per-field inline validation errors.** The error list is displayed as a block above the form; individual fields are not highlighted.
- **Debounced or live validation.** Validation runs only on submit, not on every keystroke.
- **Updating `createUser` validation.** The create-user form still does its own simple empty-string check. Migrating it to the same `{ result, errors }` pattern could be a future step.

## 6) Files Changed

| File | Change | Purpose |
|---|---|---|
| `src/data/store.js` | **Modified** | Added `currentUserId` ref, `currentUser` computed, `setCurrentUser()`; changed `createComment` to derive author from current user and return `{ comment, errors }` with validation |
| `src/components/AppHeader.vue` | **Modified** | Added "Viewing as" user dropdown; imports `getUsers`, `currentUser`, `setCurrentUser` from store |
| `src/components/CommentForm.vue` | **Modified** | Removed author dropdown; shows "Posting as" label from `currentUser`; displays validation errors from store; simplified `submit()` |
| `docs/agent-notes/03.md` | **New** | This file |

## 7) Manual Verification Checklist

- [ ] `npm run build` succeeds.
- [ ] The header displays a "Viewing as" dropdown on the right, defaulting to Alice Martin.
- [ ] Changing the dropdown updates the "Posting as" label in the comment form reactively.
- [ ] Submitting an empty comment shows "Comment cannot be empty." error.
- [ ] Submitting a valid comment adds it with the currently selected user as author.
- [ ] The error list clears after a successful submission.
- [ ] The textarea clears after a successful submission.
- [ ] The comment count increments correctly.
- [ ] Switching to a different user and posting a comment attributes it to that user.
- [ ] Newly created users (via the Users page) appear in the "Viewing as" dropdown.
- [ ] Page refresh resets the viewing user to Alice and clears any added comments.

## 8) Known Issues / Follow-ups

- **`createComment` is coupled to `currentUserId`.** There is no way to create a comment on behalf of a different user without first calling `setCurrentUser`. If a future feature needs to attribute comments to arbitrary users (e.g., an admin impersonation mode), the API would need to accept an optional `authorId` override.
- **`createUser` does not follow the same `{ result, errors }` pattern.** It still returns the user directly and relies on the component for empty-string checks. Harmonizing the mutation APIs could be a follow-up.
- **No visual feedback on the "Viewing as" change.** Switching users is silent apart from the "Posting as" label updating. A toast or subtle highlight could make the state change more apparent.
- **The viewing-as dropdown could grow long.** With many dynamically created users, the `<select>` will become unwieldy. A searchable combobox or avatar-based selector could be considered.
