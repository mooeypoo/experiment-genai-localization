# Step 07 — Internationalization (French & Spanish)

## 1) Summary

This step adds full internationalization (i18n) support for English, French, and Spanish. A lightweight custom i18n module provides a reactive `locale` ref and a `t(key, params)` translation function. Three locale files define all UI strings. Every component was updated to use `t()` for headings, labels, placeholders, buttons, and dynamic text. Validation error messages in the store were changed from hardcoded strings to translation keys, which components resolve at render time via `t()`. A language switcher dropdown was added to the header. Date formatting uses `toLocaleDateString(locale)` to produce locale-appropriate date strings.

## 2) Decisions & Rationale

### Custom i18n module instead of vue-i18n
The project philosophy favors minimal dependencies and vanilla JS. `vue-i18n` is a full-featured library (~40 KB gzipped) with pluralization rules, number/date formatting, component interpolation, and tooling integrations — none of which are needed for this demo's scale. A custom module totaling ~30 lines provides: a reactive locale ref, a dot-path message resolver, `{param}` interpolation, and a fallback to English. This is transparent, debuggable, and educational.

### Translation keys as dot-path strings
Keys follow a `namespace.key` convention (e.g., `nav.post`, `validation.nameRequired`). Dot-path resolution is a single `reduce` over `split('.')`, which is simple to implement and read. The namespace groups keys by domain (nav, post, comment, user, validation, lang), making it easy to find and maintain translations.

### Locale files as JS modules (not JSON)
Locale definitions are `.js` files exporting plain objects, not `.json` files. This allows comments (for translator context), avoids Vite's JSON import behavior quirks, and keeps the import syntax consistent with the rest of the codebase.

### Store returns translation keys; components resolve them
The store's `createUser` and `createComment` now return error arrays like `['validation.nameRequired']` instead of `['Display name is required.']`. Components render errors with `{{ t(key, { max: BIO_MAX_LENGTH }) }}`. This design means:
- **Errors are always in the current language**, even if the user switches language while errors are displayed (because `t()` reads the reactive `locale` at render time, not at error-creation time).
- **The store remains language-agnostic.** It deals with keys, not display strings.
- **Interpolation parameters** (like `{max}`) are passed at the call site, keeping the store free of formatting concerns.

### Fallback chain: current locale → English → raw key
If a key is missing from the current locale file, `t()` tries English. If English also lacks it, the raw key string is returned. This makes partial translations safe — a translator can leave gaps and the UI degrades gracefully to English rather than showing blanks or crashing.

### `{param}` interpolation (not ICU MessageFormat)
Simple `{placeholder}` replacement covers the app's needs (only `{count}` and `{max}` are currently used). ICU MessageFormat would support pluralization, gender, and select — but adds complexity and a parser. If pluralization becomes necessary (e.g., "1 comment" vs. "3 comments"), this could be revisited.

### Dates use `toLocaleDateString(locale)` directly
Rather than building a date formatting abstraction, the `locale` ref is passed to the browser's `toLocaleDateString()`. This produces culturally appropriate date strings (e.g., "2/25/2026" in English, "25/02/2026" in French, "25/2/2026" in Spanish) with no extra code.

### Language switcher in the header
A `LanguageSwitcher` component was added alongside the "Viewing as" dropdown, grouped in a `header-controls` wrapper. Both controls are pushed to the right with `margin-left: auto`. The switcher shows language names in their own language (English, Français, Español) so users can find their language regardless of what the current UI language is.

### User-generated content is not translated
Post titles, bodies, comments, user names, and bios remain in their original language. Only UI chrome (labels, headings, buttons, validation messages, placeholders) is translated. Translating user-generated content would require a completely different system (machine translation, per-language content authoring) and is out of scope.

## 3) Ambiguities Encountered

### Should we use vue-i18n or a custom solution?
**Options considered:**
1. `vue-i18n` — industry standard, rich features, TypeScript support.
2. Custom module — minimal, transparent, no dependency.
3. Vue's `provide/inject` with a translation object.

**Resolution:** Option 2. The app has ~40 translatable strings, no pluralization rules, and no build-time extraction needs. A custom module is proportionate to the scale. Option 3 would work but adds provide/inject ceremony; a module-level import is simpler.

### Should the store return translated strings or translation keys?
**Options considered:**
1. Store imports `t()` and returns fully translated error strings.
2. Store returns translation keys; components call `t()` at render time.

**Resolution:** Option 2. If the store returned translated strings, switching language while errors are displayed would leave stale strings in the old language. Returning keys and resolving at render time means the errors reactively update when the locale changes. It also keeps the store decoupled from the presentation layer.

### How to handle interpolation in validation messages?
**Options considered:**
1. Store returns keys with embedded params (e.g., `'validation.bioTooLong|max=160'`), parsed by `t()`.
2. Components pass params to `t()` at the call site.
3. Store returns structured error objects `{ key, params }`.

**Resolution:** Option 2. The component knows the context (e.g., `BIO_MAX_LENGTH`) and passes it: `t(key, { max: BIO_MAX_LENGTH })`. This keeps the store simple (it just pushes key strings) and avoids inventing a param-encoding scheme. The downside is that the component must know which keys need which params, but in practice this is obvious and documented by the locale files.

### Should the `<html lang>` attribute update?
**Options considered:**
1. Update `document.documentElement.lang` when the locale changes.
2. Leave it as `en`.

**Resolution:** Option 2 for now. Updating it would require a side effect in `setLocale` or a watcher. It's a small accessibility improvement but wasn't requested and can be added later.

### Should language preference persist across refreshes?
**Options considered:**
1. Save to `localStorage` and restore on load.
2. Reset to English on every page load.

**Resolution:** Option 2. The app's philosophy is "refresh resets everything." Persisting language would be inconsistent with the non-persistent data layer. If persistence is added to data later, language can follow.

## 4) Tradeoffs

| Decision | Upside | Downside |
|---|---|---|
| Custom i18n (no library) | Zero dependencies; fully transparent | No pluralization, no tooling (extraction, linting), no TypeScript types |
| Translation keys from store | Errors update reactively on language switch; store is language-agnostic | Components must call `t()` on error keys; slightly more template complexity |
| JS locale files (not JSON) | Allows comments; consistent imports | Not directly usable by external translation tools that expect JSON |
| `{param}` interpolation | Covers current needs simply | No pluralization; "1 Comments" vs "2 Comments" not handled |
| No `localStorage` persistence | Consistent with ephemeral data model | User must re-select language after every refresh |
| Language names in their own language | Users can always find their language | Inconsistent with the rest of the UI's current language |

## 5) Non-Goals

- **Translating user-generated content.** Post titles/bodies, comments, bios, and user names are not translated.
- **Pluralization rules.** "Comments (1)" and "Comments (3)" use the same template. Proper pluralization (e.g., "1 commentaire" vs. "3 commentaires") is not handled.
- **Right-to-left (RTL) support.** No RTL languages are included.
- **Locale-aware number formatting.** The character counter uses plain `N / 160`, not locale-formatted numbers.
- **Build-time translation extraction.** No tooling scans source for translation keys. Keys are manually maintained.
- **Language persistence.** Locale resets to English on page refresh.

## 6) Files Changed

| File | Change | Purpose |
|---|---|---|
| `src/i18n/index.js` | **New** | Core i18n: `locale` ref, `t()` function, `setLocale()`, `SUPPORTED_LOCALES`, fallback chain |
| `src/i18n/locales/en.js` | **New** | English translations (~40 keys) |
| `src/i18n/locales/fr.js` | **New** | French translations |
| `src/i18n/locales/es.js` | **New** | Spanish translations |
| `src/components/LanguageSwitcher.vue` | **New** | Language dropdown component |
| `src/components/AppHeader.vue` | **Modified** | Added `LanguageSwitcher`; wrapped controls in `header-controls` div; brand text uses `t()` |
| `src/components/NavBar.vue` | **Modified** | Link text uses `t('nav.post')`, `t('nav.users')` |
| `src/components/CommentForm.vue` | **Modified** | All text uses `t()`; errors rendered via `t(key)` |
| `src/components/CommentList.vue` | **Modified** | "Unknown" fallback uses `t()`; dates use `locale` |
| `src/components/CreateUserForm.vue` | **Modified** | All labels, placeholders, button text use `t()`; errors rendered via `t(key, params)` |
| `src/views/PostView.vue` | **Modified** | Comments heading uses `t()` with interpolation; dates use `locale`; not-found text uses `t()` |
| `src/views/UsersView.vue` | **Modified** | Heading uses `t()` |
| `src/views/UserProfileView.vue` | **Modified** | "No bio yet." and "User not found." use `t()` |
| `src/data/store.js` | **Modified** | Validation errors changed from strings to translation keys |
| `docs/agent-notes/07.md` | **New** | This file |

## 7) Manual Verification Checklist

- [ ] `npm run build` succeeds.
- [ ] Default language is English; all text renders in English.
- [ ] Switching to Français: brand, nav, labels, headings, placeholders, buttons all render in French.
- [ ] Switching to Español: same verification — all UI chrome in Spanish.
- [ ] Dates format changes with locale (e.g., "2/25/2026" → "25/02/2026" → "25/2/2026").
- [ ] Submitting an empty comment in French shows "Le commentaire ne peut pas être vide."
- [ ] Submitting an empty display name in Spanish shows "El nombre completo es obligatorio."
- [ ] Bio over-limit error includes the interpolated max value (e.g., "160") in all three languages.
- [ ] Switching language while a validation error is displayed updates the error to the new language.
- [ ] User-generated content (post body, comment text, user names) is unaffected by language switch.
- [ ] Language names in the switcher dropdown always show in their own language (English, Français, Español).
- [ ] The "Viewing as" label translates correctly in all three languages.

## 8) Known Issues / Follow-ups

- **No pluralization.** "Comments (1)" should ideally be "Comment (1)" in English, "Commentaire (1)" in French, etc. The current `{count}` interpolation doesn't select singular/plural forms.
- **Post content is not localized.** The seeded post title and body are in English regardless of UI language. Translating content is a fundamentally different problem.
- **`<html lang>` attribute does not update.** Screen readers and search engines use this for language identification. A future step could sync it with the locale ref.
- **No localStorage persistence for language.** The user must re-select their language after every page refresh.
- **Translation quality.** The French and Spanish translations were written by an AI, not a native speaker. They may contain unnatural phrasing or errors. Professional review is recommended before any real deployment.
- **No translation key validation.** If a key is mistyped in a component, the raw key string is displayed. A development-mode warning could help catch these.
